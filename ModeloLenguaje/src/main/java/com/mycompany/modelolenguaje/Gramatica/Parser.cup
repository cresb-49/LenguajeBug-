package com.mycompany.modelolenguaje.Gramatica;

import com.mycompany.modelolenguaje.Lenguaje.Abstracto.*;
import com.mycompany.modelolenguaje.Lenguaje.Abstracto.Retorno.Tipo;
import com.mycompany.modelolenguaje.Lenguaje.Exprecion.*;
import com.mycompany.modelolenguaje.Lenguaje.Instrucciones.*;

import com.mycompany.modelolenguaje.Lenguaje.Exprecion.Operacion.OpcionOperacion;
import com.mycompany.modelolenguaje.Lenguaje.Exprecion.Relacional.OpcionRelacional;

import com.mycompany.modelolenguaje.Lenguaje.Exprecion.Logica.OpcionLogica;


import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java_cup.runtime.*;

class ParserBug;

parser code {:
    // Connect this parser to a scanner!

    private static final String ERROR_TYPE_SIN = "Sintactico";
    private static final String ERROR_TYPE_SEM = "Semantico";
    
    public ParserBug (LexerBug lexerBug){ 
        super(lexerBug);
    }

    public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }
    
    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        Token tok = (Token) cur_token.value;
        if(tok!=null){
            if (cur_token.sym == ParserBugSym.EOF) {
                String er = "Simbolo inesperado, se esperaba: "+ simbolosTerminalesBug.obtenerSimbolos(expected_token_ids()).toString();
            } else {
                String er = "Simbolo inesperado, se esperaba: "+ simbolosTerminalesBug.obtenerSimbolos(expected_token_ids()).toString();
            }
        }else{
            String er = "Simbolo inesperado, se esperaba: "+ simbolosTerminalesBug.obtenerSimbolos(expected_token_ids()).toString();
        }
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == ParserBugSym.EOF) {
            String er = "Error irrecuperable se llego al final del archivo";
        } else {
            Token tok = (Token) cur_token.value;
            String er = "Error irrecuperable resuelva el error anterior";
        }
    }

    private void semantic_error(Token token,String contexto) {

    }

    private void asignarTipoDatoDeclaracion(List<Declaracion> lista,int tipo){
      for (Declaracion declaracion : lista) {
        declaracion.setTipo(tipo);
      }
    }
:}

/* define how to connect to the scanner! */
//scan with {: return this.LexerBug.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal Token  ERROR;
terminal Token  PRINT;
terminal Token  IMPORTAR,REFFILE,INCERTEZA;
terminal Token  INT,DOUBLE,BOOL,STRING,CHAR,VOID;
terminal Token  MAS,MENOS,MUL,DIV,MOD,POT,UMINUS,MAQ,MEQ,MAI,MEI,AND,OR,XOR,NOT,INCER,EQUAL,DIF,EQ,SUMAR,RESTAR;
terminal Token  PAR_A,PAR_C,COR_A,COR_C,LL_A,LL_C,SEMICOLON,COMA,DOT,DDOT;
terminal Token  ENTERO,DECIMAL,CADENA,CARACTER,TRUE,FALSE;
terminal Token  ID;
terminal Token  FOR,WHILE,IF,ELSE;
terminal Token  RETURN,CONTINUAR,BREAK;


/* Non terminals */
non terminal                    inicio,intrucciones;
non terminal List<Declaracion>  parametros,listaDeclaracion;
non terminal Integer            tipoDato,opPara;
non terminal List<Exprecion>    enviar;
non terminal Exprecion          exp,f;
non terminal Sentencias         sentencias;
non terminal Instruccion        instruc,print,para,si,mientras,declaracion,asignacion,funcion,globales;

/* Precedences */

precedence left     MAS, MENOS;
precedence left     MUL, DIV, MOD;
precedence right    POT;
precedence left     UMINUS;
precedence nonassoc MEQ,MAQ,MEI,MAI,EQUAL,DIF,INCER;
precedence left     OR;
precedence left     XOR;
precedence left     AND;
precedence left     NOT;


/* Inicio de las reglas gramticales*/

inicio    ::= intrucciones
;

intrucciones    ::= intrucciones globales
                |   globales
;

globales    ::= funcion:d {:RESULT = d;:}
            |   declaracion:d {:RESULT = d;:}
            |   asignacion:d {:RESULT = d;:}
            |   INCERTEZA:r DECIMAL:val SEMICOLON {:RESULT = new Incerteza(r.linea, r.columna, (double) val.value);:}
            |   IMPORTAR:r REFFILE:id SEMICOLON {:RESULT = new Importar(id.lexema, r.linea, r.columna);:}
;

funcion ::= tipoDato ID PAR_A PAR_C LL_A LL_C
        |   tipoDato ID PAR_A PAR_C LL_A sentencias LL_C
        |   tipoDato ID PAR_A parametros PAR_C LL_A LL_C
;

sentencias  ::= sentencias:se instruc:ins
            {:
                RESULT = se;
                RESULT.agregarInstruccion(ins);
            :}
            |   instruc:ins
            {:
                RESULT = new Sentencias(new ArrayList<Instruccion>(), 0, 0);
                RESULT.agregarInstruccion(ins);
            :}
;

instruc ::= print:ins {: RESULT = ins;:}
        |   para:ins {: RESULT = ins;:}
        |   mientras:ins {: RESULT = ins;:}
        |   si:ins {: RESULT = ins;:}
        |   declaracion:ins {: RESULT = ins;:}
        |   asignacion:ins {: RESULT = ins;:}
        |   CONTINUAR:r SEMICOLON   {:RESULT = new Continuar(r.linea, r.columna);:}
        |   BREAK:r SEMICOLON {:RESULT = new Detener(r.linea, r.columna);:}
        |   RETURN:r exp:e SEMICOLON {:RESULT = new Return(e, r.linea, r.columna);:}
;

declaracion ::= tipoDato:tipo listaDeclaracion:lista SEMICOLON
            {:
                asignarTipoDatoDeclaracion(lista,tipo);
            :}
;

listaDeclaracion    ::= listaDeclaracion:l COMA ID:id EQ exp:e
                    {:
                        RESULT = l;
                        RESULT.add(new Declaracion(id.lexema, e, Tipo.ERROR.ordinal(), id.linea, id.columna));
                    :}
                    |   listaDeclaracion:l COMA ID:id
                    {:
                        RESULT = l;
                        RESULT.add(new Declaracion(id.lexema, null, Tipo.ERROR.ordinal(), id.linea, id.columna));
                    :}
                    |   ID:id EQ exp:e
                    {:
                        RESULT = new ArrayList<>();
                        RESULT.add(new Declaracion(id.lexema, e, Tipo.ERROR.ordinal(), id.linea, id.columna));
                    :}
                    |   ID:id
                    {:
                        RESULT = new ArrayList<>();
                        RESULT.add(new Declaracion(id.lexema, null, Tipo.ERROR.ordinal(), id.linea, id.columna));
                    :}
;

asignacion  ::= ID:id EQ exp:e SEMICOLON
            {:
                RESULT = new Asignacion(id.lexema,e,id.linea,id.columna);
            :}
;

si      ::= IF:r PAR_A exp:e PAR_C LL_A sentencias:s LL_C
        {:
            RESULT = new If(e, s, null , r.linea, r.columna);
        :}
        |   IF:r PAR_A exp:e PAR_C LL_A LL_C
        {:
            RESULT = new If(e, null, null , r.linea, r.columna);
        :}
;

mientras    ::= WHILE:r PAR_A exp:e PAR_C LL_A sentencias:s LL_C
            {:
                RESULT = new While(e, s, r.linea, r.columna);
            :}
            |   WHILE:r PAR_A exp:e PAR_C LL_A LL_C
            {:
                RESULT = new While(e, null, r.linea, r.columna);
            :}
;

para    ::= FOR:r PAR_A INT ID:id EQ exp:e SEMICOLON exp:c SEMICOLON opPara:op PAR_C LL_A sentencias:s LL_C
        {:
            RESULT = new For(id.lexema, e, c, op, s, r.linea, r.columna);
        :}
        |   FOR:r PAR_A INT ID:id EQ exp:e SEMICOLON exp:c SEMICOLON opPara:op PAR_C LL_A LL_C
        {:
            RESULT = new For(id.lexema, e, c, op, null, r.linea, r.columna);
        :}
;

opPara  ::= SUMAR
        {:
            RESULT = For.SUMAR;
        :}
        |   RESTAR
        {:
            RESULT = For.RESTAR;
        :}
;

print   ::= PRINT:r PAR_A exp:e PAR_C SEMICOLON
        {:
            RESULT = new Print(e,new ArrayList<>(), null, r.linea, r.columna);
        :}
        |   PRINT:r PAR_A exp:e COMA enviar:p PAR_C SEMICOLON
        {:
            RESULT = new Print(e, p, null, r.linea, r.columna);
        :}
;

parametros  ::= parametros:r COMA tipoDato:tipo ID:id
            {:
                RESULT = r;
                RESULT.add(new Declaracion(id.lexema, null, tipo, id.linea, id.columna));
            :}
            |   tipoDato:tipo ID:id
            {:
                RESULT = new ArrayList<>();
                RESULT.add(new Declaracion(id.lexema, null, tipo, id.linea, id.columna));
            :}
;

enviar  ::= enviar:r COMA exp:e
        {:
            RESULT = r;
            RESULT.add(e);
        :}
        |   exp:e
        {:
            RESULT = new ArrayList<>();
            RESULT.add(e);
        :}
;

tipoDato    ::= INT
            {:
                RESULT = Tipo.INT.ordinal();
            :}
            |   STRING
            {:
                RESULT = Tipo.STRING.ordinal();
            :}
            |   CHAR
            {:
                RESULT = Tipo.CHAR.ordinal();
            :}
            |   DOUBLE
            {:
                RESULT = Tipo.DOUBLE.ordinal();
            :}
            |   BOOL
            {:
                RESULT = Tipo.BOOLEAN.ordinal();
            :}
            |   VOID
            {:
                RESULT = Tipo.VOID.ordinal();
            :}
;
exp     ::= MENOS:r exp:e2
        {:
            Literal e1 = new Literal(-1, Tipo.INT.ordinal(), r.linea, r.columna);
            RESULT = new Operacion(e1, e2, OpcionOperacion.MUL.ordinal(), r.linea, r.columna);
        :}
        %prec UMINUS
        |   exp:e1 MAS:r exp:e2
        {:
            RESULT = new Operacion(e1, e2, OpcionOperacion.SUMA.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MENOS:r exp:e2
        {:
            RESULT = new Operacion(e1, e2, OpcionOperacion.RESTA.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 DIV:r exp:e2
        {:
            RESULT = new Operacion(e1, e2, OpcionOperacion.DIV.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 POT:r exp:e2
        {:
            RESULT = new Operacion(e1, e2, OpcionOperacion.POT.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MUL:r exp:e2
        {:
            RESULT = new Operacion(e1, e2, OpcionOperacion.MUL.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MOD:r exp:e2
        {:
            RESULT = new Operacion(e1, e2, OpcionOperacion.MOD.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MAQ:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.MAYOR.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MEQ:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.MENOR.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MAI:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.MAYOR_IGUAL.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 MEI:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.MENOR_IGUAL.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 DIF:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.DIFERENTE.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 EQUAL:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.IGUAL.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 INCER:r exp:e2
        {:
            RESULT = new Relacional(e1, e2,OpcionRelacional.INCERTEZA.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 OR:r exp:e2
        {:
            RESULT = new Logica(e1, e2, OpcionLogica.OR.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 XOR:r exp:e2
        {:
            RESULT = new Logica(e1, e2, OpcionLogica.XOR.ordinal(), r.linea, r.columna);
        :}
        |   exp:e1 AND:r exp:e2
        {:
            RESULT = new Logica(e1, e2, OpcionLogica.AND.ordinal(), r.linea, r.columna);
        :}
        |   NOT:r exp:e
        {:
            RESULT = new Logica(e, e, OpcionLogica.NOT.ordinal(),r.linea , r.columna);
        :}
        |   f:e
        {:
            RESULT = e;
        :}
;

f       ::= PAR_A exp:e PAR_C
        {:
            RESULT = e;
        :}
        |   ENTERO:e
        {:
            RESULT = new Literal(e.value, Tipo.INT.ordinal(), e.linea, e.columna);
        :}
        |   DECIMAL:e
        {:
            RESULT = new Literal(e.value, Tipo.DOUBLE.ordinal(), e.linea, e.columna);
        :}
        |   CADENA:e
        {:
            RESULT = new Literal(e.value, Tipo.STRING.ordinal(), e.linea, e.columna);
        :}
        |   CARACTER:e
        {:
            RESULT = new Literal(e.value, Tipo.CHAR.ordinal(), e.linea, e.columna);
        :}
        |   TRUE:e
        {:
            RESULT = new Literal(e.value, Tipo.BOOLEAN.ordinal(), e.linea, e.columna);
        :}
        |   FALSE:e
        {:
            RESULT = new Literal(e.value, Tipo.BOOLEAN.ordinal(), e.linea, e.columna);
        :}
        |   ID:e
        {:
            RESULT = new Variable(e.lexema, e.linea, e.columna);
        :}
        |   ID:e PAR_A PAR_C
        {:
            RESULT = new ValFuncion(e.lexema, new ArrayList<Exprecion>(), e.linea, e.columna);
        :}
        |   ID:e PAR_A enviar:p PAR_C
        {:
            RESULT = new ValFuncion(e.lexema, p, e.linea, e.columna);
        :}
;
