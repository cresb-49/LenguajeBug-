package com.mycompany.modelolenguaje.Gramatica;

import java.util.ArrayList;
import java.util.Collections;
import java_cup.runtime.*;

class ParserBug;

parser code {:
    // Connect this parser to a scanner!

    private static final String ERROR_TYPE_SIN = "Sintactico";
    private static final String ERROR_TYPE_SEM = "Semantico";
    
    public ParserBug (LexerBug lexerBug){ 
        super(lexerBug);
    }

    public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }
    
    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        Token tok = (Token) cur_token.value;
        if(tok!=null){
            if (cur_token.sym == ParserBugSym.EOF) {
                String er = "Simbolo inesperado, se esperaba: "+ simbolosTerminalesBug.obtenerSimbolos(expected_token_ids()).toString();
            } else {
                String er = "Simbolo inesperado, se esperaba: "+ simbolosTerminalesBug.obtenerSimbolos(expected_token_ids()).toString();
            }
        }else{
            String er = "Simbolo inesperado, se esperaba: "+ simbolosTerminalesBug.obtenerSimbolos(expected_token_ids()).toString();
        }
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == ParserBugSym.EOF) {
            String er = "Error irrecuperable se llego al final del archivo";
        } else {
            Token tok = (Token) cur_token.value;
            String er = "Error irrecuperable resuelva el error anterior";
        }
    }

    private void semantic_error(Token token,String contexto) {

    }
:}

/* define how to connect to the scanner! */
//scan with {: return this.LexerBug.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal Token  ERROR;
terminal Token  PRINT;
terminal Token  INT,DOUBLE,BOOL,STRING,CHAR,VOID;
terminal Token  MAS,MENOS,MUL,DIV,MOD,POT,UMINUS,MAQ,MEQ,MAI,MEI,AND,OR,XOR,NOT,INCER,EQUAL,DIF;
terminal Token  PAR_A,PAR_C,COR_A,COR_C,LL_A,LL_C,SEMICOLON,COMA;
terminal Token  ENTERO,DECIMAL,CADENA,CARACTER,TRUE,FALSE;
terminal Token  ID;
terminal Token  FOR,WHILE,IF;


/* Non terminals */
non terminal            inicio,exp,f,tipoDato,funcion,parametros,enviar,intrucciones;
non terminal            sentencias,instruc,print,para,si,mientras;

/* Precedences */

precedence left     MAS, MENOS;
precedence left     MUL, DIV, MOD;
precedence right    POT;
precedence left     UMINUS;
precedence nonassoc MEQ,MAQ,MEI,MAI,EQUAL,DIF,INCER;
precedence left     OR;
precedence left     XOR;
precedence left     AND;
precedence left     NOT;


/* Inicio de las reglas gramticales*/

inicio    ::= intrucciones
;

intrucciones    ::= intrucciones funcion
                |   funcion
;

funcion ::= tipoDato ID PAR_A PAR_C LL_A LL_C
        |   tipoDato ID PAR_A PAR_C LL_A sentencias LL_C
        |   tipoDato ID PAR_A parametros PAR_C LL_A LL_C
;

sentencias  ::= sentencias instruc
            |   instruc
;

instruc ::= print
        |   para
        |   mientras
        |   si
;

si      ::= IF PAR_A exp PAR_C LL_A sentencias LL_C
        |   IF PAR_A exp PAR_C LL_A LL_C
;

mientras    ::= WHILE PAR_A exp PAR_C LL_A sentencias LL_C
            |   WHILE PAR_A exp PAR_C LL_A LL_C
;

para    ::= FOR PAR_A PAR_C LL_A sentencias LL_C
        |   FOR PAR_A PAR_C LL_A LL_C
;

print   ::= PRINT PAR_A exp PAR_C SEMICOLON
        |   PRINT PAR_A exp COMA enviar PAR_C SEMICOLON
;

parametros  ::= parametros COMA tipoDato ID
            |   tipoDato ID
;

enviar  ::= enviar COMA exp
        |   exp
;

tipoDato    ::= INT
            |   STRING
            |   CHAR
            |   DOUBLE
            |   BOOL
            |   VOID
;
exp     ::= MENOS exp
        {:
        :}
        %prec UMINUS
        |   exp MAS exp
        {:
        :}
        |   exp MENOS exp
        {:
        :}
        |   exp DIV exp
        {:
        :}
        |   exp POT exp
        {:
        :}
        |   exp MUL exp
        {:
        :}
        |   exp MOD exp
        {:
        :}
        |   exp MAQ exp
        {:
        :}
        |   exp MEQ exp
        {:
        :}
        |   exp MAI exp
        {:
        :}
        |   exp MEI exp
        {:
        :}
        |   exp DIF exp
        {:
        :}
        |   exp EQUAL exp
        {:
        :}
        |   exp INCER exp
        {:
        :}
        |   exp OR exp
        {:
        :}
        |   exp XOR exp
        {:
        :}
        |   exp AND exp
        {:
        :}
        |   NOT exp
        {:
        :}
        |   f
        {:
        :}
;

f       ::= PAR_A exp PAR_C
        {:
        :}
        |   ENTERO
        {:
        :}
        |   DECIMAL
        {:
        :}
        |   CADENA
        {:
        :}
        |   CARACTER
        {:
        :}
        |   TRUE
        {:
        :}
        |   FALSE
        {:
        :}
        |   ID
        {:
        :}
        |   ID PAR_A PAR_C
        {:
        :}
        |   ID PAR_A enviar PAR_C
        {:
        :}
;
